---
phase: 02-invoice-resource
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - nodes/Fortnox/Fortnox.node.ts
autonomous: true
requirements: [INV-01, INV-02, INV-03, INV-04, INV-05, INV-06, INV-07, INV-08, OPS-01, OPS-02, OPS-03]

must_haves:
  truths:
    - "User can create an invoice with customer number, line items, and optional fields like due date and currency"
    - "User can retrieve a single invoice by DocumentNumber"
    - "User can list invoices with filters and pagination using Return All toggle"
    - "User can update a draft invoice's fields and line items"
    - "User can bookkeep, cancel, credit, and send an invoice via single-operation actions"
    - "Failed items are handled gracefully with continueOnFail() support"
    - "Package builds and lints cleanly with all Invoice operations wired"
  artifacts:
    - path: "nodes/Fortnox/Fortnox.node.ts"
      provides: "Complete Fortnox node with Invoice resource routing in execute()"
      exports: ["Fortnox"]
      contains: "resource === 'invoice'"
  key_links:
    - from: "nodes/Fortnox/Fortnox.node.ts"
      to: "nodes/Fortnox/GenericFunctions.ts"
      via: "import { fortnoxApiRequest, fortnoxApiRequestAllItems }"
      pattern: "import.*fortnoxApiRequest.*from.*GenericFunctions"
    - from: "nodes/Fortnox/Fortnox.node.ts"
      to: "nodes/Fortnox/InvoiceDescription.ts"
      via: "import { invoiceOperations, invoiceFields } spread into properties"
      pattern: "invoiceOperations.*invoiceFields"
    - from: "nodes/Fortnox/Fortnox.node.ts execute()"
      to: "Fortnox API endpoints"
      via: "fortnoxApiRequest calls to /3/invoices"
      pattern: "fortnoxApiRequest.*'/3/invoices"
---

<objective>
Wire the Invoice resource into the Fortnox node's execute() method, connecting all 8 operations to the Fortnox API through the GenericFunctions helpers, and verify the complete package builds and lints cleanly.

Purpose: This plan turns the stub Fortnox node into a fully functional Invoice automation tool. It imports the GenericFunctions helpers (rate-limit retry, pagination, error translation) and InvoiceDescription (UI fields), then implements the resource+operation routing that maps user inputs to Fortnox API calls. After this plan, a user can create, read, list, update, bookkeep, cancel, credit, and send invoices.

Output: Updated Fortnox.node.ts with complete Invoice resource implementation. Clean build producing dist/ output.
</objective>

<execution_context>
@/Users/adamnoren/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adamnoren/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-invoice-resource/02-RESEARCH.md
@.planning/phases/02-invoice-resource/02-01-SUMMARY.md

<interfaces>
<!-- Interfaces from Plan 02-01 that this plan consumes. -->

From nodes/Fortnox/GenericFunctions.ts (created by Plan 02-01):
```typescript
export async function fortnoxApiRequest(
    this: IExecuteFunctions | ILoadOptionsFunctions | IHookFunctions,
    method: IHttpRequestMethods,
    endpoint: string,
    body: IDataObject = {},
    qs: IDataObject = {},
): Promise<any>;

export async function fortnoxApiRequestAllItems(
    this: IExecuteFunctions | ILoadOptionsFunctions,
    method: IHttpRequestMethods,
    endpoint: string,
    resourceKey: string,
    body: IDataObject = {},
    qs: IDataObject = {},
): Promise<IDataObject[]>;
```

From nodes/Fortnox/InvoiceDescription.ts (created by Plan 02-01):
```typescript
export const invoiceOperations: INodeProperties[];
export const invoiceFields: INodeProperties[];
```

From current nodes/Fortnox/Fortnox.node.ts (Phase 1):
- Has `description.properties: []` (empty -- must be populated)
- Has `execute()` returning `[items]` passthrough (must be replaced)
- Has `methods.credentialTest.fortnoxApiTest` (KEEP this -- do not remove)
- Credential: `fortnoxApi`, testedBy: `fortnoxApiTest`

Fortnox Invoice API endpoints (from RESEARCH.md):
- POST   /3/invoices                          -- Create invoice (body: { Invoice: {...} })
- GET    /3/invoices/{DocumentNumber}          -- Get invoice (response: { Invoice: {...} })
- GET    /3/invoices                           -- List invoices (response: { Invoices: [...], MetaInformation: {...} })
- PUT    /3/invoices/{DocumentNumber}          -- Update invoice (body: { Invoice: {...} })
- PUT    /3/invoices/{DocumentNumber}/bookkeep -- Bookkeep (empty body)
- PUT    /3/invoices/{DocumentNumber}/cancel   -- Cancel (empty body)
- PUT    /3/invoices/{DocumentNumber}/credit   -- Credit (empty body)
- GET    /3/invoices/{DocumentNumber}/email    -- Send email (GET, not POST!)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Invoice resource into Fortnox.node.ts with all 8 operations</name>
  <files>nodes/Fortnox/Fortnox.node.ts</files>
  <action>
Rewrite `nodes/Fortnox/Fortnox.node.ts` to add the Invoice resource with all 8 operations. KEEP the existing `methods.credentialTest.fortnoxApiTest` method exactly as-is.

**New imports to add:**
```typescript
import type { IDataObject, INodeExecutionData } from 'n8n-workflow';
import { fortnoxApiRequest, fortnoxApiRequestAllItems } from './GenericFunctions';
import { invoiceOperations, invoiceFields } from './InvoiceDescription';
```

**Update description.properties:**
Replace the empty `properties: []` with:
```typescript
properties: [
    {
        displayName: 'Resource',
        name: 'resource',
        type: 'options',
        noDataExpression: true,
        options: [
            {
                name: 'Invoice',
                value: 'invoice',
            },
        ],
        default: 'invoice',
    },
    ...invoiceOperations,
    ...invoiceFields,
],
```

**Replace execute() method** with the full resource+operation routing. Structure:

```typescript
async execute(this: IExecuteFunctions) {
    const items = this.getInputData();
    const returnData: INodeExecutionData[] = [];
    const resource = this.getNodeParameter('resource', 0);
    const operation = this.getNodeParameter('operation', 0);

    for (let i = 0; i < items.length; i++) {
        try {
            let responseData;

            if (resource === 'invoice') {
                // ... operation routing (see below)
            }

            const executionData = this.helpers.constructExecutionMetaData(
                this.helpers.returnJsonArray(responseData as IDataObject),
                { itemData: { item: i } },
            );
            returnData.push(...executionData);
        } catch (error) {
            if (this.continueOnFail()) {
                const executionData = this.helpers.constructExecutionMetaData(
                    this.helpers.returnJsonArray({ error: (error as Error).message }),
                    { itemData: { item: i } },
                );
                returnData.push(...executionData);
                continue;
            }
            throw error;
        }
    }
    return [returnData];
}
```

**Operation implementations inside the `if (resource === 'invoice')` block:**

**create (INV-01):**
- Get `customerNumber` (required), `invoiceRows`, `additionalFields` from parameters
- Build body: `{ Invoice: { CustomerNumber: customerNumber } }`
- If invoiceRows has rows: `body.Invoice.InvoiceRows = invoiceRows.row` (fixedCollection stores under the sub-property name)
- Merge additionalFields into body.Invoice (iterate keys, assign if value is not empty string)
- Call `fortnoxApiRequest.call(this, 'POST', '/3/invoices', body)`
- Extract: `responseData = response.Invoice`

**get (INV-02):**
- Get `documentNumber` from parameters
- Call `fortnoxApiRequest.call(this, 'GET', \`/3/invoices/${documentNumber}\`)`
- Extract: `responseData = response.Invoice`

**getMany (INV-03, OPS-01):**
- Get `returnAll`, filters from parameters
- Build qs object from filters: iterate filter keys, assign non-empty values to qs
- If returnAll: call `fortnoxApiRequestAllItems.call(this, 'GET', '/3/invoices', 'Invoices', {}, qs)`
  - `responseData = response` (already an array)
- Else: get `limit`, set `qs.limit = limit`, call `fortnoxApiRequest.call(this, 'GET', '/3/invoices', {}, qs)`
  - `responseData = response.Invoices` (array from list envelope)

**update (INV-04):**
- Get `documentNumber`, `updateFields` from parameters
- Build body: `{ Invoice: {} }`
- If updateFields has invoiceRows with rows: `body.Invoice.InvoiceRows = updateFields.invoiceRows.row`, then delete updateFields.invoiceRows
- Merge remaining updateFields into body.Invoice (iterate keys, assign if value is not empty string)
- Call `fortnoxApiRequest.call(this, 'PUT', \`/3/invoices/${documentNumber}\`, body)`
- Extract: `responseData = response.Invoice`

**bookkeep (INV-05):**
- Get `documentNumber`
- Call `fortnoxApiRequest.call(this, 'PUT', \`/3/invoices/${documentNumber}/bookkeep\`)`
- Extract: `responseData = response.Invoice`

**cancel (INV-06):**
- Get `documentNumber`
- Call `fortnoxApiRequest.call(this, 'PUT', \`/3/invoices/${documentNumber}/cancel\`)`
- Extract: `responseData = response.Invoice`

**credit (INV-07):**
- Get `documentNumber`
- Call `fortnoxApiRequest.call(this, 'PUT', \`/3/invoices/${documentNumber}/credit\`)`
- Extract: `responseData = response.Invoice`

**send (INV-08):**
- Get `documentNumber`
- IMPORTANT: This endpoint uses GET, not POST! (Pitfall 5 from research)
- Call `fortnoxApiRequest.call(this, 'GET', \`/3/invoices/${documentNumber}/email\`)`
- Extract: `responseData = response.Invoice`

**Critical implementation notes:**
- continueOnFail() check in catch block is MANDATORY -- without it, one failed item stops all subsequent items
- constructExecutionMetaData with itemData tracks which input item produced which output
- Action endpoints (bookkeep, cancel, credit) send NO body -- do not pass `{}` as body, use the default empty object which fortnoxApiRequest checks with `Object.keys(body).length > 0`
- The send/email endpoint is GET not POST (unusual but documented)
- For additionalFields/updateFields merge: skip empty strings to avoid sending blank values that would overwrite existing data in Fortnox
  </action>
  <verify>
    <automated>cd /Users/adamnoren/n8n-nodes-fortnox && npx tsc --noEmit --strict nodes/Fortnox/Fortnox.node.ts 2>&1 | head -20</automated>
  </verify>
  <done>Fortnox.node.ts compiles cleanly. Has Resource dropdown with Invoice. Has 8 operation cases in execute() (create, get, getMany, update, bookkeep, cancel, credit, send). Imports from GenericFunctions and InvoiceDescription. continueOnFail() handled in catch block. credentialTest preserved.</done>
</task>

<task type="auto">
  <name>Task 2: Build and lint the complete package</name>
  <files>nodes/Fortnox/Fortnox.node.ts</files>
  <action>
Run the full build and lint pipeline to verify Phase 2 produces a clean package:

1. Run `npm run build` -- must produce dist/ files for all three source files (GenericFunctions.js, InvoiceDescription.js, Fortnox.node.js + their .d.ts)
2. Run `npm run lint` -- must pass with zero errors. If lint errors appear:
   - Fix description strings that end with periods (n8n rule: descriptions must NOT end with '.')
   - Fix any displayName casing issues (must be sentence case)
   - Fix any import ordering issues
   - Fix any unused variable warnings
3. Run `npx tsc --noEmit` as final TypeScript check

If lint or build fails, fix the issues in the affected files before completing. Do NOT skip lint errors.

Common lint issues to watch for:
- Descriptions ending with a period
- Missing 'action' field on operation options
- displayName not in expected format
- Unused imports

After clean build+lint, verify dist/ contains the expected files:
- dist/nodes/Fortnox/Fortnox.node.js
- dist/nodes/Fortnox/GenericFunctions.js
- dist/nodes/Fortnox/InvoiceDescription.js
  </action>
  <verify>
    <automated>cd /Users/adamnoren/n8n-nodes-fortnox && npm run build 2>&1 | tail -5 && npm run lint 2>&1 | tail -5 && echo "--- dist check ---" && ls dist/nodes/Fortnox/</automated>
  </verify>
  <done>Package builds with zero errors. Lint passes with zero errors. dist/ contains Fortnox.node.js, GenericFunctions.js, InvoiceDescription.js and their type declarations. Package is ready for testing against real Fortnox API.</done>
</task>

</tasks>

<verification>
1. Full build succeeds: `npm run build` exits 0
2. Lint passes: `npm run lint` exits 0 with no errors
3. TypeScript compiles: `npx tsc --noEmit` exits 0
4. Node has Invoice resource with 8 operations
5. execute() routes all 8 operations to correct Fortnox API endpoints
6. continueOnFail() pattern implemented in execute() catch block
7. dist/ contains all three compiled JS files
</verification>

<success_criteria>
- Fortnox.node.ts has Resource dropdown with Invoice and 8 operations wired in execute()
- create builds Invoice body with CustomerNumber, InvoiceRows, and additionalFields
- getMany supports returnAll with fortnoxApiRequestAllItems and limit with single-page request
- Action operations (bookkeep, cancel, credit) use correct HTTP methods and empty bodies
- Send uses GET method (not POST) per Fortnox API
- Package builds and lints with zero errors
- dist/ has all expected output files
</success_criteria>

<output>
After completion, create `.planning/phases/02-invoice-resource/02-02-SUMMARY.md`
</output>
